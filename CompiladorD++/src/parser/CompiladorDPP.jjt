/**
 * LINGUAGEM D++
 */

options
{
  static = true;
}

PARSER_BEGIN(CompiladorDPP)

package parser;
import recovery.*;

public class CompiladorDPP
{
  public static void main(String args []) throws ParseException
  {
    CompiladorDPP cdpp = new CompiladorDPP(System.in);
    SimpleNode sn = cdpp.Programa();
    sn.dump(" ");
    /*try
    {
      CompiladorDPP cdpp = new CompiladorDPP(System.in);
      cdpp.Programa();
    }
    catch (ParseException e)
    {
      System.out.println(e.getMessage());
      System.out.println("CompiladorDPP: Erros encontrados na análise.");
    }*/
  }

  static public String im(int x)
  {
    int k;
    String s;
    s = tokenImage [x];
    k = s.lastIndexOf("\"");
    try
    {
      s = s.substring(1, k);
    }
    catch (StringIndexOutOfBoundsException e)
    {
    }
    return s;
  }

  static Token lastError = null;

  static boolean eof; // variável que indica se EOF foi alcançado

  // o método abaixo consome tokens até alcançar um que pertença ao conjunto
  // de sincronização
  static void consumeUntil(RecoverySet g, 
  ParseException e, 
  String met) throws ParseEOFException, 
  ParseException
  {
    Token tok;
    System.out.println();
    System.out.println("*** " + met + " ***");
    System.out.println("     Conjunto de sincroniza\u00e7\u00e3o: " + g);
    if (g == null) throw e; // se o conjunto é null, propaga a exceção
    tok = getToken(1); // pega token corrente
    while (!eof)	
    { // se não chegou ao fim do arquivo
      if (g.contains(tok.kind))
      { //achou um token no conjunto
        System.out.println("     Encontrado token de sincroniza\u00e7\u00e3o: " + 
        im(tok.kind));
        break;
      }
      System.out.println("     Ignorando o token: " + im(tok.kind));
      getNextToken(); // pega próximo token       
      tok = getToken(1);
      if (tok.kind == EOF && !g.contains(EOF))  // fim da entrada?   
      eof = true;
    }
    if (tok != lastError)
    {
      System.out.println(e.getMessage());
      lastError = tok;
    }
    if (eof) 
    throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
  }
}

PARSER_END(CompiladorDPP)

SKIP : 
{ 
	" "|"\n" | "\r" | "\r\n" 
}

TOKEN:
{
	  <TIPO:"num"|"dec"|"str"|"chr">{System.out.println("TIPO -> "+image);}
	| <NUM: (["0"-"9"])+ > {System.out.print("NUMERO "+image+"\r\n");}
	| <ID: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])*> {System.out.print("IDENTIFICADOR -> "+image+"\r\n");}
	| <CAD: ["a"-"z","A"-"Z","0"-"9"](["a"-"z","A"-"Z","0"-"9"])*>{System.out.print("CADEIA -> "+image+"\r\n");}
}

TOKEN : /* OPERADORES */
{ 
	  <ATRIB : "="> {System.out.println("ATRIBUIÇÃO -> "+image+"\r\n");}
	| <SOM : "+" > {System.out.println("SOMAR -> "+image+"\r\n");}
	| <SUB:"-">{System.out.println("SUBTRAIR -> "+image+"\r\n");}
	| <MULT:"*">{System.out.println("MULTIPLICAR -> "+image+"\r\n");}
	| <DIV:"/">{System.out.println("DIVIDIR -> "+image+"\r\n");}
	| <INCR: "++" >{System.out.println("INCREMENTO -> "+image+"\r\n");}
	| <DECR: "--" >{System.out.println("DECREMENTO -> "+image+"\r\n");}
}

TOKEN: /* PALAVRAS RESERVADAS */
{
	  /*<MAIN: "public static void Main() ">{System.out.println("MAIN -> "+image);}*/
	  <PROG: "Programa " > {System.out.println("PROGRAMA -> "+image);}
	| <IF: "se " >{System.out.println("IF -> "+image);}
	| <ELSE:"senao " >{System.out.println("ELSE -> "+image);}
	| <ELSEIF:"senaose " >{System.out.println("ELSE IF -> "+image);}
	| <FOR:"para " >{System.out.println("FOR -> "+image);}
	| <SWITCH:"alternativa " >{System.out.println("SWITCH -> "+image);}
	| <CASE:"caso " >{System.out.println("CASE -> "+image);}
	| <BREAK:"termina " >{System.out.println("BREAK -> "+image);}
	| <DEFAUL:"predef " >{System.out.println("DEFAULT -> "+image);}
	| <DO:"faca " >{System.out.println("DO -> "+image);}
	| <WHILE:"enquanto " >{System.out.println("WHILE -> "+image);}
	| <WRITE:"escreva " >{System.out.println("WRITE -> "+image);}
	| <READ:"leia " >{System.out.println("READ -> "+image);}
}

TOKEN:
{
      <APAREN: "(" >{System.out.println("ABRE PARENTESE -> "+image);}
	| <FPAREN: ")" >{System.out.println("FECHA PARENTESE -> "+image);}
	| <ACHAVE: "{" >{System.out.println("ABRE CHAVE -> "+image);}
	| <FCHAVE: "}" >{System.out.println("FECHA CHAVE -> "+image);}
	| <ACOUCH: "[" >{System.out.println("ABRE COUCHETE -> "+image);}
	| <FCOUCH: "]" >{System.out.println("FECHA COUCHETE -> "+image);}
	| <PEV: ";" >{System.out.println("PONTO E VÍRGULA -> "+image);}
	| <VIR: "," >{System.out.println("VÍRGULA -> "+image);}
	| <PON: "." >{System.out.println("PONTO -> "+image);}
}

TOKEN:
{
	  <IG: "==" >{System.out.println("IGUAL -> "+image);}
	| <ME: "<" >{System.out.println("MENOR -> "+image);}
	| <MENI: "<=" >{System.out.println("MENOR OU IGUAL -> "+image);}
	| <MA: ">" >{System.out.println("MAIOR -> "+image);}
	| <MAII: ">=" >{System.out.println("MAIOR OU IGUAL -> "+image);}
	| <DIF: "!=" >{System.out.println("DIFERENTE -> "+image);}
	| <OR: "||" >{System.out.println("OR -> "+image);}
	| <AND: "&&">{System.out.println("AND -> "+image);}
}

SimpleNode Programa():
{}
{
	<PROG><ID><ACHAVE>Bloco()<FCHAVE><EOF>
	{ return jjtThis; }
	
}
void Bloco():
{}
{
	DeclaracaoGlobal() | Principal()
}
void DeclaracaoGlobal():
{}
{
	<TIPO>VariaveisGlobais()	
}

void VariaveisGlobais():
{}
{
	<ID> <PEV> W()
}
void W():
{}
{
	DeclaracaoGlobal() | Principal()	
}

void Principal():
{}
{
	/*<MAIN>*/
	/*<ACHAVE>*/Sentencas()/*<FCHAVE>*/
}

void DeclaracaoLocal():
{}
{
	<TIPO>VariaveisLocais()
}
void VariaveisLocais():
{}
{
	<ID> <PEV> VS()
}

void VS():
{}
{
	DeclaracaoLocal() | Sentencas()
}

void Sentencas():
{}
{
 (
	  DeclaracaoLocal()
    | SentencaIf() 	
	| SentencaFor()
	| SentencaDo()	
	| SentencaAtribuicao()
	| SentencaWrite()
	| SentencaRead()	
	|<EOF>
 )*
}

void A():
{}
{
	  Comparacoes()
}

void Comparacoes():
{}
{
	Valor()Operadores()Valor()
}
void Valor():
{}
{
	<ID> | <NUM>
}
void Expressao():
{}
{
	/*<NUM> | <ID> | */<ID><SOM><ID><PEV> /*| <NUM> OpAritmetico() <NUM> | 
	<ID> OpAritmetico() <ID>|
	<ID> OpAritmetico() <NUM> | <ID>*/
}

void Operadores():
{}
{
	  <IG> 
	| <ME> 
	| <MENI> 
	| <MA> 
	| <MAII> 
	| <DIF> 
}
void OpAritmetico():
{}
{
	  <SOM>
	| <SUB>
	| <MULT>
	| <DIV>
}

void SentencaIf():
{}
{
	<IF><APAREN> A() <FPAREN> <ACHAVE> Sentencas() <FCHAVE> 
}

void SentencaFor():
{}
{
	<FOR> <APAREN> SentencaAtribuicao() <PEV> Comparacoes() SentencaAtribuicao() <FPAREN> <ACHAVE> Sentencas() <FCHAVE>
}

void SentencaDo():
{}
{
	<DO> <ACHAVE>Sentencas() <FCHAVE> <WHILE> <APAREN> Comparacoes() <FPAREN>
}

void SentencaAtribuicao():
{}
{
	<ID> <ATRIB> Expressao()
}

void SentencaWrite():
{}
{
	<WRITE> <APAREN> Expressao() <FPAREN> <PEV> 
}

void SentencaRead():
{}
{
	<READ><APAREN><FPAREN><PEV>
}